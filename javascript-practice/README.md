Warmup

1. Reverse a String

Write a function to reverse a given string.

2. Check for Palindrome

Determine if a given string is a palindrome (reads the same forward and backward).

3. Sum of an Array

Write a function to calculate the sum of numbers in an array.

4. Count Vowels in a String

Write a function to count the number of vowels (a, e, i, o, u) in a given string.

5. Filter Even Numbers

Filter out even numbers from an array.

6. Capitalize Each Word

Write a function to capitalize the first letter of each word in a string.

7. Find Duplicates in an Array

Write a function to find duplicate elements in an array.

8. Merge Two Sorted Arrays

Merge two sorted arrays into one sorted array.

9. Generate Fibonacci Sequence

Generate the first n numbers in the Fibonacci sequence.

10. Validate an Email Address

Write a function to validate an email address format.

Curated List of 30 Medium and Difficult JavaScript/TypeScript Problems

Core JavaScript Concepts

    1.	Deep Clone an Object: Implement a function to deep clone any JavaScript object, handling edge cases like circular references.
    2.	Memoization Utility: Create a memoization utility that caches results of pure functions based on their arguments.
    3.	Custom Promise.all Implementation: Implement your own version of Promise.all that accepts an array of promises and resolves when all of them are resolved.
    4.	EventEmitter Implementation: Build a class that mimics Node.js’s EventEmitter, allowing users to on, emit, and off events.
    5.	Lodash-style get: Write a function similar to Lodash’s get to safely access nested properties in an object.
    6.	Custom debounce and throttle: Implement debounce and throttle utilities with TypeScript types.
    7.	Flatten Nested Arrays: Write a function to flatten deeply nested arrays, e.g., [1, [2, [3, [4]]]] → [1, 2, 3, 4].

Advanced JavaScript

    8.	Custom Promise Class: Implement a custom Promise class from scratch.
    9.	Virtual DOM: Build a lightweight virtual DOM diffing algorithm and apply changes to the real DOM.
    10.	Observer Pattern: Implement the Observer pattern to manage subscriptions and notify subscribers of state changes.
    11.	State Management Store: Create a Redux-like store with actions, reducers, and state management.
    12.	Currying: Implement a generic function to curry any provided function.
    13.	Circular Queue: Build a circular queue data structure and use it in a real-world example.
    14.	AOP (Aspect-Oriented Programming): Implement an AOP utility for JavaScript functions, allowing pre/post hooks.

TypeScript Challenges

    15.	Recursive Type Flattening: Create a TypeScript utility type to recursively flatten nested object types.
    16.	Custom PartialDeep Type: Implement a utility type PartialDeep that makes all properties (and nested properties) optional.
    17.	JSON Schema to TypeScript Type: Write a function that generates TypeScript types from JSON schemas dynamically.
    18.	Type-Safe EventEmitter: Extend the EventEmitter implementation to ensure type safety for events and handlers.
    19.	Validate Function Arguments: Create a decorator that validates function arguments based on TypeScript types at runtime.
    20.	Generic Matrix Operations: Implement type-safe matrix operations (addition, multiplication) using generics.
    21.	Dynamic Validation Utility: Write a utility to dynamically validate data against a TypeScript interface.

ES2023 and Modern JavaScript Features

    22.	Change Array by Copy: Build a library that uses ES2023 array-copying methods to manipulate data immutably.
    23.	WeakRefs and FinalizationRegistry: Demonstrate the use of WeakRef and FinalizationRegistry by implementing a lightweight garbage collection tracker.
    24.	Pattern Matching: Simulate pattern matching in TypeScript with type-safe exhaustive case handling.
    25.	Temporal API: Write a scheduling utility using the Temporal API for date and time manipulation.
    26.	Decorators: Implement and use TypeScript decorators to add metadata and behavior to classes and methods.

Algorithms and Data Structures

    27.	Trie Data Structure: Implement a Trie for efficient prefix-based searches in a collection of strings.
    28.	LRU Cache: Build an LRU (Least Recently Used) cache with TypeScript, ensuring type safety.
    29.	AST Parser: Parse a simple mathematical expression (e.g., 3 + 5 * (2 - 1)) into an Abstract Syntax Tree (AST) and evaluate it.
    30.	Diff Algorithm: Write a diff algorithm to compare two objects and list their differences.

Bonus

    •	Functional Programming Challenge: Rewrite a small imperative JavaScript program in a functional programming style using TypeScript.
    •	Concurrency Management: Build a concurrency controller that ensures only a specific number of asynchronous operations run at once.
    •	Web Worker Utility: Create a utility to simplify using Web Workers in JavaScript with TypeScript types.

These challenges cover core JavaScript concepts, TypeScript typing, modern ECMAScript features, and algorithmic thinking. Solving them will deepen your understanding and prepare you to tackle real-world problems effectively.
